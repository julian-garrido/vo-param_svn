\documentclass[a4paper,11pt] {ivoa}
\usepackage{geometry}                % See geometry.pdf to learn the layout
% options. There are lots.
\geometry{a4paper}                   % ... or a4paper or a5paper or ...
% \geometry{landscape}                % Activate for for rotated page geometry
% \usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty
% line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{color}
\usepackage{xcolor}
\usepackage{listings}

\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\title{Implementing Note of the Framework built around PDL}
% Give author list: separate different authors with \\ 
% You can add email addresses with links \url{mailto:yourname@ivoa.net}
\author{Carlo Maria Zw\"olf}
\newcommand{\pdlversion}{0.1}
\newcommand{\pdldate}{\today}

%I have marked sections which I am unsure of with this
\newcommand{\tocheck}[1]{{\color{red} #1}}

% Give date and version number
\date{\pdldate}

% Choose one document type from below
%\ivoatype{IVOA Note}
\ivoatype{IVOA Working Draft}
%\ivoatype{IVOA Proposed Recommendation}
%\ivoatype{IVOA Recommendation}
\ivoagroup{GWS / Theory}
\version{\pdlversion}
\def\SVN$#1: #2 ${\expandafter\def\csname SVN#1\endcsname{#2}}
\SVN$Rev: 123 $

\urlthisversion{\pdlversion:  \pdldate\ (SVN Revision \SVNRev)}
\urllastversion{N/A}
\previousversion{
}

\begin{document}
\maketitle

\tableofcontents

\section{Introduction}\label{intro}
BLA BLA

\section{The package structure}

\section{Java Objects corresponding to the PDL data Model}
They are all generated using JAX-B on the PDL XML schema. The generated classes corresponds to the PDL 


\section{The CommonsObject package}\label{commons}
This package contains the classes 
\begin{itemize}
\item GeneralParameter.java
\item GeneralPatameterAlgebra.java
\end{itemize}

\subsection{The  GeneralParameter.java class }\label{generalParameter}
This class is the core PDL and is used for handling all the parameters. It is a way for encapsulating the usual basic types (integer, double, boolean, string) into an object. Moreover the modular design of this class allow users to easily define new types.\\

This attributes of this class are
\begin{itemize}
\item a field {\it value} of String type,\\
\item a field {\it type} of String type,\\
\item a field {\it description} of String type,\\
\item a field {\it visitor} of Ivisitor type (cf. paragraph \ref{visitor} for the definition of this interface).\\ 
\end{itemize}

The constructor of this class takes as arguments the quadruplet  {\it  value, type, description, visitor} and invoke the method {\it visit(GeneralParameter)} on the object we are creating. If all the test contained in the visitor (typically this methods verify if the value provided could be cast to the type contained into the {\it type} field) pass with no problem, then the object is created. If a problem is encountered, the constructor throws an {\it InvalidParameterException } exception explaining the reasons of the problem.\\

With this mechanisms, the validation of a GeneralParameter is automatically performed at its own construction. All the existing instances of GeneralParameter are natively validated. Moreover, just by modifying the content of the visitor class passed as arguments, developers could easily add support for new types. 

\subsection{The GeneralParameterAlgebra.java class}\label{gpalgebra}
This class is implemented using the singleton pattern. In the following, let $g_i$ be a family of GeneralParameter instances.
This class  contains the methods for computing:
\begin{itemize}
\item  the sum $g_r = g_i + g_j$;\\
\item the multiplication $g_r = g_i \cdot g_j$;\\
\item the difference of $g_r = g_i - g_j$. ;\\
For these last three items, if the both $g_i$ and $g_j$ are integer, the resulting GeneralParameter will be of integer type too. If one of the two is a real, then the result will be a real (this is internally hold using double types).\\
\item the power $g_r = g_i^{g_j}$. Since the native Java Math.pow method provide a double, the result will always 
be a GeneralParameter of real type;\\
\item the absolute value $|g_r|$. Since the native Math.abs method provide a double, the result will always be a GeneralParameter of real type;\\
\item the function $f(g_i)$, $\displaystyle f() \in \left\{ \sin() , \cos(), \tan(), \sin^{-1}(), \cos^{-1}(), \tan^{-1}(),  \exp(), \log() \right\}$. The result wil be a GeneralParamter of real type;
\item the sum of all the components $g_{i,j}$ of a vector of general parameters $\vec g_i$ : $g_r = \sum_j g_{i,j}$. By the choice of our implementation, the result is a GeneralParameter of real type;
\item the product of all the components $g_{i,j}$ of a vector of general parameters $\vec g_i$ : $g_r = \prod_j g_{i,j}$. By the choice of our implementation, the result is a GeneralParameter of real type;
\item the size of a vector $\vec g_i$. In this case the result is a generalParameter of type Intger and the incapsulated value will be the size of the vector.\\ 
\end{itemize} 
All  these operations (excepted the last one) are performed only if  $g_i$ (and $g_j$ too when it appears) is (are) numerical. In the other cases, this method will throw an InvalidExpression exception explaining the reasons of the problem;\\

\noindent Moreover this class contains methods for characterizing  instances of GeneralParameter:
\begin{itemize}
\item {\it areGeneralParameterEqual} takes $g_i$ and $g_j$ and return a boolean. This last is true if 
\begin{itemize}
\item both $g_i$, $g_j$ are numerical and the difference of the values $v(g_i)$ and $v(g_j)$ encapsulated in these objects is smaller than $\epsilon = 0.0000001$ ($v(g_i)-v(g_j)<\epsilon$), or 
\item the type of $g_i$  is equal (in the Java equalsIgnoreCase String sense) to the type of $g_j$ and the value if $g_i$ is equal (again, in the Java equalsIgnoreCase String sense) to the value of $g_j$.
\end{itemize} 
\item {\it isFirstGreaterThanSecond} takes $g_i$, $g_j$ and a boolean $r$. The result is true if 
\begin{itemize}
\item $r$ is true and $v(g_i) \geq v(g_j)$, or
\item $r$ is false and $v(g_i) > v(g_j)$.
\end{itemize}
\item {\it isFirstSmallerThanSecond} takes $g_i$, $g_j$ and a boolean $r$. The result is true if 
\begin{itemize}
\item $r$ is true and $v(g_i) \leq v(g_j)$, or
\item $r$ is false and $v(g_i) < v(g_j)$.
\end{itemize}
\item {\it isGeneralParameterInteger} takes $g_i$ and returns a boolean. This last is true if $v(g_i) \in \mathbb N$.
\item {\it isGeneralParameterReal} takes $g_i$ and returns a boolean. This last is true if $v(g_i) \in \mathbb R$.
\end{itemize}
 
 \section{The visitors package}\label{visitor}
This package contains the visitors classes used by the {\it GeneralParameter} class constructor (cf. paragraph \ref{generalParameter}).\\

\subsection{The visitors objects}
The interface {\it Ivisitor} describe the method {\it visit} which takes as argument the {\it GeneralParameter} instance to inspect.\\
The abstract {\it AbstractVisitor} class implements the {\it Ivisitor} interface. It defines 
\begin{itemize}
\item the abstract method {\it buildCriteriaList} which return a list of {\it Icriteria} (cf. par. \ref{criteria}). Developer has to implement this function in order to define his own list of criteria. By default, we provide the {\it GeneralParameterVisitor} class (cf. the end of this paragraph).
\item the {\it visit} function: the previous method is invoked and, for every {Icriteria} object returned, we verify if the couple (type, value) of the {\it GeneralParameter} instance passed as argument verify the criterion. If at least one criterion is satisfied, than the visit methods end positevely. If no criterion is satisfied, the methods throws an {\it InvalidParameterException} explaining the reasons of the problem.
\end{itemize}
The {\it GeneralParameterVisitor} class is the concrete implementation of {\it AbstractVisitor}. It defines the method {\it buildCriteriaList}. The list returned contains a {\it RealCriteria}, an {\it IntegerCriteria}, a {\it BooleanCriteria} and a {\it StringCriteria} (cf. par. \ref{criteria}).  

\subsection{The criteria objects}\label{criteria}
All the criteria we are going to define implements the {\it Icriteria} interface. This last describe the methods:
\begin{itemize}
\item {\it getAuthorizedCriteriaType}, which returns the String containing the type authorized by the concrete criterion implementing the interface.
\item {\it verifyCriteria}, which takes as argument a couple (type,value) characterizing a {\it GeneralParameter}. It returns the boolean true if the criterion is satisfied and false in the other case.
\end{itemize}
This interface is implemented by {\it RealCriteria}, an {\it IntegerCriteria}, a {\it BooleanCriteria} and a {\it StringCriteria}.

\subsubsection{The RealCriteria}
In this class, the method {\it getAuthorizedCriteriaType} returns the String ('real') {\bf used in the PDL grammar} for specifying that a parameter is of real type.\\
The {\it VerifyCriteria} method returns the boolean true if the type of the {\it GeneralParameter} is 'real' and if the value of the same  {\it GeneralParameter} could be cast to a double type with no errors. If the type of the  {\it GeneralParameter} is not 'real', this methods return false. Finally if the type of the {\it GeneralParameter} is 'real' and the value cannot be casted to a double, this method throws an {\it InvalidParameterException} explaining the reasons of the problem.

\subsubsection{The IntegerCriteria}
In this class, the method {\it getAuthorizedCriteriaType} returns the String ('Integer') {\bf used in the PDL grammar} for specifying that a parameter is of Integer type.\\
The {\it VerifyCriteria} method returns the boolean true if the type of the {\it GeneralParameter} is 'Integer' and if the value of the same  {\it GeneralParameter} could be cast to an Integer type with no errors. If the type of the  {\it GeneralParameter} is not 'Integer', this methods return false. Finally if the type of the {\it GeneralParameter} is 'Integer' and the value cannot be casted to an Integer, this method throws an {\it InvalidParameterException} explaining the reasons of the problem.

\subsubsection{The BooleanCriteria}
In this class, the method {\it getAuthorizedCriteriaType} returns the String ('Boolean') {\bf used in the PDL grammar} for specifying that a parameter is of Boolean type.\\
The {\it VerifyCriteria} method returns the boolean true if the type of the {\it GeneralParameter} is 'Boolean' and if the value of the same  {\it GeneralParameter} is equal to 'true' or 'false'. If the type of the  {\it GeneralParameter} is not 'Boolean', this methods return false. Finally if the type of the {\it GeneralParameter} is 'Boolean' and the value is not 'true' or 'false', this method throws an {\it InvalidParameterException} explaining the reasons of the problem.

\subsubsection{The StringCriteria}
In this class, the method {\it getAuthorizedCriteriaType} returns the String ('String') {\bf used in the PDL grammar} for specifying that a parameter is of String type.\\
The {\it VerifyCriteria} method returns the boolean true if the type of the {\it GeneralParameter} is 'String' and the boolean false in the other cases.

\section{The pdl.interpreter.expression package}
In this package are contained all the classes for interpreting and parsing PDL expressions.\\
The entry point for understanding the expression interpreting mechanism is the abstract class {\it ExpressionParser}. 
It describes the abstract method {\it parse}, which interprets the expression invoking the method. The result of this method is a list of {\it GeneralParameter} instances. Since in PDL expressions are vectorial, the $i$-th element of that list corresponds to the result of the interpretation of $i$-th component of the vector expression.
The abstract class {\it ExpressionParser} is used, jointly with the polymorphism mechanism for building the {\it ExpressionParserFactory}

\subsection{The ExpressionParserFactory class}
This class is built by implementing the {\it singleton} pattern and is, as its name indicates, an implementation of the {\it factory} pattern.\\
The method {\it buildParser} takes as argument an instance of the PDL {\it Expression} object and returns an {\it ExpressionParser}.
More precisely, using introspection, this function analyze the instance of the PDL Expression:
\begin{itemize}
\item if the {\it Expression} is an instance of {\it AtomicConstantExpression} then the methods returns a {\it AtomicConstantExpressionParser};
\item if the {\it Expression} is an instance of {\it AtomicParameterExpression} then the methods returns a {\it AtomicParameterExpressionParser};
\item if the {\it Expression} is an instance of {\it FunctionExpression} then the methods returns a {\it FunctionExpressionParser};
\item if the {\it Expression} is an instance of {\it Function} then the methods returns a {\it FunctionParser};
\item if the {\it Expression} is an instance of {\it ParenthesisContent} then the methods returns a {\it ParenthesisContentParser};
\end{itemize} 
It is important to note that, since in PDL expressions are recursive, this factory will be invoked inside every concrete class implementing {\it ExpressionParser}.\\
In what follows, we are going to describe all these concrete classes returned by the  {\it buildParser} method (and implementing the {\it ExpressionParser}).


\subsection{The ExpressionWithPowerParser class}
This abstract class inherits from {\it ExpressionParser} and is used for factoring the code of all the classes interpreting PDL expressions involving powers. 
It specifies the method {\it evaluatePower} which takes as arguments two lists of {\it GeneralParameter}, one list for the base (let us note $g_i^{base}$ its elements) 
and the other for the exponent (let us note $g_i^{exp}$ its elements). This method returns:
\begin{itemize}
\item the base list of $g_i^{base}$, if the expos ant list is null;\\
\item the list whose elements are $\displaystyle \left(g_i^{base}\right)^{g_i^{exp}}$, if both lists have the same size. The power operation is performed in the {\it GeneralParameter} sense, using the methods described in paragraph \ref{gpalgebra}.
\item the list whose elements are  $\displaystyle \left(g_i^{base}\right)^{g_0^{exp}}$, if the exponent list contains only one element $g_0^{exp}$.
\end{itemize}
In the other cases, the  {\it evaluatePower} method throws and {\it InvalidExpression} exception, specifying the reasons of the problem.

\subsection{The AtomicConstantExpressionParser}
This class implements the {\it ExpressionWithPowerParser} and is used for interpreting the PDL {AtomicParameterExpression} instances. Indeed this class has an attribute of type {\it AtomicParameterExpression} whose value is initialized by the class constructor.\\
In the overridden method {\it parse}, the following actions are performed:
\begin{itemize}
\item the instance of the SingleParameter referenced by the expression, is retrieved using the {\it Utilities} class methods.
\item if the power of the expression is not null, then we convert the power expression into a List of {\it GeneralParameter} by building (using the {\it ExpressionParserFactory}) the had hoc parser and invoking its {\it parse} method.
\item The expression (without the operation part) is evaluated: Using the {\it Utilities} class we get the list of {\it GeneralParameter} corresponding to the user provided input vector for the SingleParameter contained into the AtomicConstantExpression. We verify that the dimension of that list corresponds to the value put in the dimension field of the SingleParameter. If this test is negative we throws an {\it InvalidExpression} exception. If the test is positive, we invoke the method {\it evaluatePower} inherited from the {\it ExpressionWithPowerParser} superclass. 
\item If the {\it Operation} contained into the {\it AtomicParameterExpression} is not null, we evaluate the results of this operation (cf XXX, the result of the expression without the operation is in this case our first operand).
\item Finally, the methods returns the list of {\it GeneralParameter} corresponding to the passage through the previous stages.  
\end{itemize}



\end{document}





 
